<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Moldes STL</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            margin: 30px 0;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(102, 126, 234, 0.05);
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.1);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.15);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            color: #667eea;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 10px;
        }

        .upload-subtext {
            color: #999;
            font-size: 0.9em;
        }

        #fileInput {
            display: none;
        }

        .controls {
            display: none;
            margin: 30px 0;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }

        .control-group {
            margin: 20px 0;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        input[type="number"] {
            width: 100px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress {
            display: none;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .viewer {
            margin: 30px 0;
            height: 400px;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: #f8f9fa;
            display: none;
        }

        .result {
            display: none;
            margin: 30px 0;
            padding: 20px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 10px;
            border: 2px solid #4caf50;
        }

        .error {
            display: none;
            margin: 20px 0;
            padding: 15px;
            background: rgba(244, 67, 54, 0.1);
            border: 2px solid #f44336;
            border-radius: 10px;
            color: #d32f2f;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .upload-area {
                padding: 40px 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè≠ Generador de Moldes STL</h1>
        <p>Sube tu archivo STL y genera autom√°ticamente un molde con encastres para impresi√≥n 3D</p>

        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üìÅ</div>
            <div class="upload-text">Arrastra tu archivo STL aqu√≠</div>
            <div class="upload-subtext">o haz clic para seleccionar</div>
            <input type="file" id="fileInput" accept=".stl" />
        </div>

        <div class="controls" id="controls">
            <h3>Configuraci√≥n del Molde</h3>
            
            <div class="control-group">
                <label for="wallThickness">Grosor de Paredes (mm):</label>
                <input type="range" id="wallThickness" min="1" max="10" value="3" step="0.5">
                <input type="number" id="wallThicknessValue" min="1" max="10" value="3" step="0.5">
            </div>

            <div class="control-group">
                <label for="tolerance">Tolerancia (mm):</label>
                <input type="range" id="tolerance" min="0.1" max="2" value="0.5" step="0.1">
                <input type="number" id="toleranceValue" min="0.1" max="2" value="0.5" step="0.1">
            </div>

            <div class="control-group">
                <label for="keySize">Tama√±o de Encastres (mm):</label>
                <input type="range" id="keySize" min="2" max="15" value="8" step="1">
                <input type="number" id="keySizeValue" min="2" max="15" value="8" step="1">
            </div>

            <div class="control-group">
                <label for="keySpacing">Espaciado de Encastres (mm):</label>
                <input type="range" id="keySpacing" min="10" max="50" value="25" step="5">
                <input type="number" id="keySpacingValue" min="10" max="50" value="25" step="5">
            </div>
        </div>

        <div class="progress" id="progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressText">Procesando...</p>
        </div>

        <div class="viewer" id="viewer"></div>

        <div class="error" id="errorMsg"></div>

        <div class="result" id="result">
            <h3>‚úÖ Molde Generado Exitosamente</h3>
            <p>Tu molde ha sido generado con encastres autom√°ticos</p>
            <button class="btn" id="downloadBtn">üì• Descargar Molde STL</button>
            <button class="btn" id="downloadTopBtn">üì• Descargar Parte Superior</button>
            <button class="btn" id="downloadBottomBtn">üì• Descargar Parte Inferior</button>
        </div>

        <button class="btn" id="generateBtn" style="display: none;">üîß Generar Molde</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="stl-processor.js"></script>
    <script>
        // Variables globales
        let uploadedFile = null;
        let scene, camera, renderer;
        let originalMesh = null;
        let moldMesh = null;

        // Referencias a elementos del DOM
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const controls = document.getElementById('controls');
        const generateBtn = document.getElementById('generateBtn');
        const progress = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const viewer = document.getElementById('viewer');
        const result = document.getElementById('result');
        const errorMsg = document.getElementById('errorMsg');

        // Control sliders
        const wallThickness = document.getElementById('wallThickness');
        const wallThicknessValue = document.getElementById('wallThicknessValue');
        const tolerance = document.getElementById('tolerance');
        const toleranceValue = document.getElementById('toleranceValue');
        const keySize = document.getElementById('keySize');
        const keySizeValue = document.getElementById('keySizeValue');
        const keySpacing = document.getElementById('keySpacing');
        const keySpacingValue = document.getElementById('keySpacingValue');

        // Sincronizaci√≥n de sliders con inputs num√©ricos
        function syncSliderWithInput(slider, input) {
            slider.addEventListener('input', () => {
                input.value = slider.value;
            });
            input.addEventListener('input', () => {
                slider.value = input.value;
            });
        }

        syncSliderWithInput(wallThickness, wallThicknessValue);
        syncSliderWithInput(tolerance, toleranceValue);
        syncSliderWithInput(keySize, keySizeValue);
        syncSliderWithInput(keySpacing, keySpacingValue);

        // Configuraci√≥n de drag & drop
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);

        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        }

        function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.stl')) {
                showError('Por favor selecciona un archivo STL v√°lido');
                return;
            }

            uploadedFile = file;
            uploadArea.innerHTML = `
                <div class="upload-icon">‚úÖ</div>
                <div class="upload-text">Archivo cargado: ${file.name}</div>
                <div class="upload-subtext">Tama√±o: ${(file.size / 1024 / 1024).toFixed(2)} MB</div>
            `;

            controls.style.display = 'block';
            generateBtn.style.display = 'inline-block';
            hideError();
            hideResult();
        }

        // Generaci√≥n del molde
        generateBtn.addEventListener('click', generateMold);

        async function generateMold() {
            if (!uploadedFile) {
                showError('Por favor selecciona un archivo STL primero');
                return;
            }

            showProgress();
            hideError();
            hideResult();

            try {
                updateProgress(10, 'Leyendo archivo STL...');
                const stlData = await readSTLFile(uploadedFile);
                
                updateProgress(30, 'Procesando geometr√≠a...');
                const geometry = parseSTL(stlData);
                
                updateProgress(50, 'Generando molde...');
                const moldData = await generateMoldFromGeometry(geometry, {
                    wallThickness: parseFloat(wallThicknessValue.value),
                    tolerance: parseFloat(toleranceValue.value),
                    keySize: parseFloat(keySizeValue.value),
                    keySpacing: parseFloat(keySpacingValue.value)
                });

                updateProgress(80, 'Renderizando vista previa...');
                await renderPreview(moldData);

                updateProgress(100, 'Completado');
                showResult(moldData);
                hideProgress();

            } catch (error) {
                console.error('Error generando molde:', error);
                showError('Error al generar el molde: ' + error.message);
                hideProgress();
            }
        }

        function readSTLFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = () => reject(new Error('Error leyendo el archivo'));
                reader.readAsArrayBuffer(file);
            });
        }

        function parseSTL(buffer) {
            // Implementaci√≥n b√°sica de parser STL
            const view = new DataView(buffer);
            let offset = 80; // Skip header
            const triangleCount = view.getUint32(offset, true);
            offset += 4;

            const vertices = [];
            const faces = [];

            for (let i = 0; i < triangleCount; i++) {
                // Skip normal (12 bytes)
                offset += 12;

                // Read vertices
                for (let j = 0; j < 3; j++) {
                    const x = view.getFloat32(offset, true);
                    const y = view.getFloat32(offset + 4, true);
                    const z = view.getFloat32(offset + 8, true);
                    vertices.push(x, y, z);
                    offset += 12;
                }

                // Add face indices
                const faceStart = i * 3;
                faces.push(faceStart, faceStart + 1, faceStart + 2);

                // Skip attribute byte count
                offset += 2;
            }

            return { vertices, faces };
        }

        async function generateMoldFromGeometry(geometry, options) {
            // Simulaci√≥n de generaci√≥n de molde
            // En una implementaci√≥n real, aqu√≠ ir√≠a el algoritmo complejo
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve({
                        topHalf: geometry,
                        bottomHalf: geometry,
                        combined: geometry
                    });
                }, 1000);
            });
        }

        async function renderPreview(moldData) {
            initThreeJS();
            
            // Crear geometr√≠a para Three.js
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(moldData.combined.vertices, 3));
            geometry.setIndex(moldData.combined.faces);
            geometry.computeVertexNormals();

            // Material
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x4CAF50,
                shininess: 30,
                transparent: true,
                opacity: 0.8
            });

            // Mesh
            moldMesh = new THREE.Mesh(geometry, material);
            scene.add(moldMesh);

            // Centrar y escalar
            const box = new THREE.Box3().setFromObject(moldMesh);
            const center = box.getCenter(new THREE.Vector3());
            moldMesh.position.sub(center);

            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 5 / maxDim;
            moldMesh.scale.setScalar(scale);

            // Posicionar c√°mara
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            viewer.style.display = 'block';
            animate();
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(75, viewer.offsetWidth / viewer.offsetHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewer.offsetWidth, viewer.offsetHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            viewer.innerHTML = '';
            viewer.appendChild(renderer.domElement);

            // Luces
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (moldMesh) {
                moldMesh.rotation.y += 0.01;
            }
            
            renderer.render(scene, camera);
        }

        // Funciones de UI
        function showProgress() {
            progress.style.display = 'block';
        }

        function hideProgress() {
            progress.style.display = 'none';
        }

        function updateProgress(percentage, text) {
            progressFill.style.width = percentage + '%';
            progressText.textContent = text;
        }

        function showResult(moldData) {
            result.style.display = 'block';
            
            // Configurar botones de descarga
            document.getElementById('downloadBtn').onclick = () => downloadSTL(moldData.combined, 'molde_completo.stl');
            document.getElementById('downloadTopBtn').onclick = () => downloadSTL(moldData.topHalf, 'molde_superior.stl');
            document.getElementById('downloadBottomBtn').onclick = () => downloadSTL(moldData.bottomHalf, 'molde_inferior.stl');
        }

        function hideResult() {
            result.style.display = 'none';
        }

        function showError(message) {
            errorMsg.textContent = message;
            errorMsg.style.display = 'block';
        }

        function hideError() {
            errorMsg.style.display = 'none';
        }

        function downloadSTL(geometryData, filename) {
            // Generar archivo STL binario
            const buffer = generateSTLBuffer(geometryData);
            const blob = new Blob([buffer], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateSTLBuffer(geometry) {
            const triangleCount = geometry.faces.length / 3;
            const buffer = new ArrayBuffer(80 + 4 + triangleCount * 50);
            const view = new DataView(buffer);
            
            // Header (80 bytes)
            let offset = 80;
            
            // Triangle count
            view.setUint32(offset, triangleCount, true);
            offset += 4;
            
            // Triangles
            for (let i = 0; i < triangleCount; i++) {
              